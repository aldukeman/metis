#ifndef STATE_PROXY_H
#define STATE_PROXY_H

#include "state.h"
#include "globals.h"

#include "symmetries/graph_creator.h"

#include <ext/hash_map>


class StateProxy {
    // This class is basically a pointer that can be reassigned even
    // though it is const. This is needed for the hash table below,
    // where a node may first be inserted with a pointer to a
    // temporary object as the key, which will then later be replaced
    // with a pointer to a heap-allocated object generated by
    // make_permanent below.
    // Despite the const-ness, mutating the key of a hash_map in place
    // is fine as long as the mutation does not affect the hash value
    // (which this one does not, as it only changes the address of the
    // state, whereas the contents of the state are used for hashing).

    // Update: This was changed from a State* to an state_var_t*
    //         that points "inside" the state to shave off some memory.
public:
    mutable state_var_t *state_data;

#ifdef CANONICAL
    mutable state_var_t *canonical_rep;
#endif

    StateProxy() {
        state_data = 0;
#ifdef CANONICAL
        canonical_rep = 0;
#endif
    }

    StateProxy(state_var_t *state_data_) {
        state_data = state_data_;
#ifdef CANONICAL
        canonical_rep = get_canonical_state(state_data_);
#endif
    }

    // This is a hack for using the old StateProxy when needed (e.g. for landmarks).
    explicit StateProxy(const State *state, bool
#ifdef CANONICAL
        no_symm
#endif
    ) {
        state_data = const_cast<state_var_t *>(state->get_buffer());
#ifdef CANONICAL
        if (no_symm) {
            canonical_rep = const_cast<state_var_t *>(state->get_buffer());
        } else {
            canonical_rep = get_canonical_state(state_data);
        }
#endif
    }

    explicit StateProxy(const State *state) {
        state_data = const_cast<state_var_t *>(state->get_buffer());
#ifdef CANONICAL
        canonical_rep = get_canonical_state(state_data);
#endif

    }

    const StateProxy &operator=(const StateProxy &other) const {
#ifdef CANONICAL
        canonical_rep = other.canonical_rep;
#endif
        state_data = other.state_data;
        return *this;
    }

    bool operator==(const StateProxy &other) const {
#ifdef CANONICAL
        return State(canonical_rep) == State(other.canonical_rep);
#endif

        return State(state_data) == State(other.state_data);
    }

    void make_permanent() const {
        state_var_t *new_buffer = new state_var_t[g_variable_domain.size()];
        for (int i = 0; i < g_variable_domain.size(); i++)
            new_buffer[i] = state_data[i];
        state_data = new_buffer;
#ifdef CANONICAL
        if(!(State(state_data) == State(canonical_rep))){
            state_var_t *new_buffer1 = new state_var_t[g_variable_domain.size()];
            for (int i = 0; i < g_variable_domain.size(); i++)
                new_buffer1[i] = canonical_rep[i];
            canonical_rep = new_buffer1;
        } else {
            canonical_rep = state_data;
        }
#endif
    }

    const state_var_t* get_canonical_state(const state_var_t* state) {
        if (!g_symmetry_graph)
            return state_data;
        return g_symmetry_graph->get_canonical_state(state);
    }
};

namespace __gnu_cxx {
template<>
struct hash<StateProxy> {
    size_t operator()(const StateProxy &state_proxy) const {
#ifdef CANONICAL
        return State(state_proxy.canonical_rep).hash();
#endif
        return State(state_proxy.state_data).hash();
    }
};
}


#endif
